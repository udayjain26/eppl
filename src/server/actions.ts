'use server'

import { auth } from '@clerk/nextjs/server'
import { db } from './db'
import { clients, stateEnum } from './db/schema'
import { nullable, z } from 'zod'
import { uuid } from 'drizzle-orm/pg-core'
import { is } from 'drizzle-orm'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'

//Form Schema for creating a client in the database
//Nullable represents optional form fields from the user's pov
const createClientFormSchema = z.object({
  uuid: z.string().uuid(),
  clientFullName: z.string().trim(),
  clientNickName: z.string().trim(),
  gstin: z.coerce.string().trim().length(15).nullable(),
  isNewClient: z.coerce.boolean().default(false),
  clientAddressLine1: z.string().trim().nullable(),
  clientAddressLine2: z.string().trim().nullable(),
  clientAddressCity: z.string().trim().nullable(),
  clientAddressState: z.enum(stateEnum.enumValues).nullable(),
  clientAddressPincode: z.coerce.string().trim().length(6).nullable(),
  createdAt: z.date(),
  updatedAt: z.date(),
})

//Can ignore uuid and created at field as it is autogenerated
const CreateClient = createClientFormSchema.omit({
  uuid: true,
  createdAt: true,
  updatedAt: true,
})

function emptyStringToNullTransformer(data: any) {
  if (typeof data === 'string' && data === '') {
    return null
  }
  return data
}

interface transformedData {
  [key: string]: any
}

export async function createClient(formData: FormData) {
  //Check if user is authenticated: Throws an uncaught error. App Breaking Throw
  const user = auth()
  if (!user.userId) {
    throw new Error('User Unauthenitcated')
  }

  //Transforming the form data to remove empty strings
  const transformedData: transformedData = {}
  formData.forEach((value, key) => {
    transformedData[key] = emptyStringToNullTransformer(value)
  })

  console.log(transformedData)

  //Validating the form fields
  const validatedFields = CreateClient.safeParse(transformedData)

  if (!validatedFields.success) {
    console.log(
      'validatedFields.error.flatten().fieldErrors',
      validatedFields.error.flatten().fieldErrors,
    )
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Failed to Create Client',
    }
  } else {
    try {
      await db.insert(clients).values(validatedFields.data)
    } catch (error) {
      return {
        message: 'Database Error: Failed to Create Invoice.',
      }
    }
  }
}
