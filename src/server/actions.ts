'use server'

import { auth } from '@clerk/nextjs/server'
import { db } from './db'
import { clients, stateEnum } from './db/schema'
import { nullable, z } from 'zod'
import { uuid } from 'drizzle-orm/pg-core'
import { is } from 'drizzle-orm'
import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'

// const zEmptyStrToUndefined = z.preprocess((arg) => {
//   if (typeof arg === 'string' && arg === '') {
//     return undefined
//   } else {
//     return arg
//   }
// }, z.string().optional())

// function emptryToNull(value: string): string | null {
//   return value === '' ? null : value
// }

// // Define a Zod schema with the custom type guard function
// const emptyToNullSchema = z.custom((val: string) => {
//   return emptryToNull(val)
// })
//Form Schema for creating a client in the database
const createClientFormSchema = z.object({
  uuid: z.string().uuid(),
  clientFullName: z
    .string()
    .min(1, { message: 'Client Full Name must not be empty' })
    .max(256),
  clientNickName: z
    .string()
    .min(1, { message: 'Client Nick Name must not be empty' })
    .max(256),
  gstin: z.string().trim().length(15),
  isNewClient: z.coerce.boolean().default(false),
  clientAddressLine1: z.string().trim(),
  clientAddressLine2: z.string().trim(),
  clientAddressCity: z.string().trim(),
  clientAddressState: z.enum(stateEnum.enumValues),
  clientAddressPincode: z.coerce.string().trim().length(6),
  createdAt: z.date(),
  updatedAt: z.date(),
})

// export type State = {
//   errors?: {
//     clientFullName?: string[]
//     clientNickName?: string[]
//     gstin?: string[]
//     isNewClient?: string[]
//     clientAddressLine1?: string[]
//     clientAddressLine2?: string[]
//     clientAddressCity?: string[]
//     clientAddressState?: string[]
//     clientAddressPincode?: string[]
//   }

//   message?: string | null
// }

//Can ignore uuid and created at field as it is autogenerated
const CreateClient = createClientFormSchema.omit({
  uuid: true,
  createdAt: true,
  updatedAt: true,
})

export async function createClient(formData: FormData) {
  console.log('formData', formData)
  const user = auth()
  if (!user.userId) {
    throw new Error('User Unauthenitcated')
  }
  const validatedFields = CreateClient.safeParse({
    clientFullName: formData.get('clientFullName'),
    clientNickName: formData.get('clientNickName'),
    gstin: formData.get('gstin'),
    isNewClient: formData.get('isNewClient'),
    clientAddressLine1: formData.get('clientAddressLine1'),
    clientAddressLine2: formData.get('clientAddressLine2'),
    clientAddressCity: formData.get('clientAddressCity'),
    clientAddressState: formData.get('clientAddressState'),
    clientAddressPincode: formData.get('clientAddressPincode'),
  })
  if (!validatedFields.success) {
    console.log(
      'validatedFields.error.flatten().fieldErrors',
      validatedFields.error.flatten().fieldErrors,
    )
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Failed to Create Client',
    }
  } else {
    try {
      await db.insert(clients).values(validatedFields.data)
    } catch (error) {
      return {
        message: 'Database Error: Failed to Create Invoice.',
      }
    }
  }
}

// await db.insert(clients).values({
//   clientName: 'Client 1',
//   clientCreationStatus: 'New',
// })
